"""Задание 1.
Выполните профилирование памяти в скриптах. Проанализируйте результат и
определите программы с наиболее эффективным использованием памяти.

Примечание: Для анализа возьмите любые 3-5 ваших РАЗНЫХ скриптов! (хотя бы 3
разных для получения оценки отл). На каждый скрипт вы должны сделать как
минимум по две реализации.

Можно взять только домашние задания с курса Основ или с текущего курса
Алгоритмов

Результаты профилирования добавьте в виде комментариев к коду. Обязательно
сделайте аналитику (что с памятью в ваших скриптах, в чем ваша оптимизация и
т.д.)

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО

Попытайтесь дополнительно свой декоратор используя ф-цию memory_usage из
memory_profiler С одновременным замером времени (timeit.default_timer())!"""

from memory_profiler import memory_usage
from timeit import default_timer
from functools import wraps
from random import randrange


def my_profiler(func):
    """Возвращает кортеж из замеров по декорируемой функции:
    фактическое использование памяти (memory_profiler.memory_usage) и
    времени (timeit.default_timer)"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        """используем wraps, чтобы скрыть работу своего декоратора и получать на
        func.__name__ не wrapper, а имя декорируемой функции func"""

        # замеры по потреблению памяти и времени
        time_start = default_timer()
        mem_start = memory_usage()
        result = func(*args, **kwargs)
        mem_usage = memory_usage()[0] - mem_start[0]
        time_usage = default_timer() - time_start

        print(f'При выполнении скрипта {func.__name__} '
              f'было использовано {mem_usage:.6f} Mib ОЗУ, '
              f'время выполнения {time_usage:.6f} сек.')
        return result
    return wrapper


@my_profiler
# @profile
def func_1(nums):
    """Сохраняет в массиве индексы четных элементов переданного массива"""
    # Решение через цикл по переданному массиву
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return new_arr


@my_profiler
def func_2(nums):
    """Сохраняет в массиве индексы четных элементов переданного массива"""
    # Решение через LC с условием
    return [idx for idx, el in enumerate(nums) if not el % 2]


@my_profiler
def func_3(nums):
    """Генератор - возвращает индексы четных элементов переданного массива"""
    # Решение через генератор
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            yield i


if __name__ == '__main__':
    CNT_ELEMS = 1000000                 # кол-во эл-тов в массиве для тестов
    MIN_ELEM, MAX_ELEM = 1000, 1000000  # мин. и макс. значение эл-та массива

    # создаем для тестов массив из CNT_ELEMS случайных целых чисел
    nums = [randrange(MIN_ELEM, MAX_ELEM) for _ in range(CNT_ELEMS)]

    print('\nСкрипт возвращающий список индексов четных элементов переданного '
          'на вход списка.')
    print(f'Исходный массив - ({CNT_ELEMS:,d} случайных элементов от '
          f'{MIN_ELEM:,d} до {MAX_ELEM:,d}): {nums[:5]} ... {nums[-5:]}\n')

    # Вывод результатов работы 3х реализаций функции
    f1, f2, f3 = func_1(nums), func_2(nums), tuple(func_3(nums))
    for idx, func in enumerate((f1, f2, f3)):
        print(f'Функцией func_{idx + 1} найдено {len(func):,d} четных эл-тов, '
              f'их индексы в исходном массиве: {func[:5]} ... {func[-5:]}')

"""
Варианты реализации 1 и 2, заполняющие массив с результатами - естественно 
потребляют память сообразно размеру массива (причем вариант 2 с lc - немного 
быстрее, но потребляет больше памяти), а вот реализация получения очередного 
значения результирующего массива через генератор (вариант 3) - памяти 
практически не потребляет, независимо от размера обрабатываемых исходных данных, 
да к тому же еще и значительно быстрее по времени отрабатывает.
Когда же я "материализую" генератор для получения сразу всех элементов - 
эффект экономии памяти пропадает и потребление по памяти будет примерно такое 
же, как и варианте 1 и 2.
"""
