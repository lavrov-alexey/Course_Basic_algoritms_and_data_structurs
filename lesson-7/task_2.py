import timeit
from random import uniform

"""2. Отсортируйте по возрастанию методом слияния одномерный вещественный
массив, заданный случайными числами на промежутке [0; 50).
Выведите на экран исходный и отсортированный массивы.

Хотя в примерах к уроку уже есть вариант реализации слияния,
попробуйте предложить другой (придумать или найти).

И попытаться сделать замеры на массивах разной длины: 10, 100, 1000, ...

Пример:
Введите число элементов: 5
Исходный - [46.11436617832828, 41.62921998361278, 18.45859540989644,
12.128870723745806, 8.025098788570562]
Отсортированный - [8.025098788570562, 12.128870723745806, 18.45859540989644,
41.62921998361278, 46.11436617832828]"""

"""Выводы. 
По сравнению с алгоритмами квадратичной сложности - рост времени выполнения 
сортировки растет не так быстро при увеличении массива, хотя на маленьких 
объемах данный алгоритм показывает время хуже, но с ростом объема сортировки - 
сложность n*log(n) - раскрывает свой потенциал"""


def merge_sort(arr):
    """Реализует сортировку слиянием переданного массива"""
    if len(arr) > 1:
        # определяем индекс среднего эл-та массива и делим массив на 2 части
        idx_cntr = len(arr) // 2
        left_arr, right_arr = arr[:idx_cntr], arr[idx_cntr:]
        # рекурсивно вызываем себя же, передавая выделенные куски массива
        merge_sort(left_arr)
        merge_sort(right_arr)

        # деление массива на части завершено, переходим к слиянию
        # заводим индексы для текущих эл-тов левого, правого и итогового архивов
        idx_left, idx_right, idx_res = 0, 0, 0

        # пока не дошли до конца обоих частей архивов
        while idx_left < len(left_arr) and idx_right < len(right_arr):
            if left_arr[idx_left] < right_arr[idx_right]:
                # если текущий эл-т слева меньше текущего справа
                arr[idx_res] = left_arr[idx_left]
                # берем в итог - левый (меньший) и двигаем левый индекс
                idx_left += 1
            else:
                # если тек. эл-т справа меньше или равен тек. слева
                # берем в итог - правый (меньший) и двигаем правый индекс
                arr[idx_res] = right_arr[idx_right]
                idx_right += 1
            # в любом случае - двигаем индекс итогового архива
            idx_res += 1

        # пока не дошли до конца левой части (правая уже кончилась)
        while idx_left < len(left_arr):
            # берем в итог тек. эл-т из левой части
            arr[idx_res] = left_arr[idx_left]
            # и двигаем левый и итоговый индексы
            idx_left += 1
            idx_res += 1

        # пока не дошли до конца правой части (левая уже кончилась)
        while idx_right < len(right_arr):
            # берем в итог тек. эл-т из правой части
            arr[idx_res] = right_arr[idx_right]
            # и двигаем правый и итоговый индексы
            idx_right += 1
            idx_res += 1
        return arr  # возвращаем отсортированный архив


if __name__ == '__main__':

    arr_cnts = (10, 100, 1000, 10000)  # размерности массивов для сортировки
    CNT_RUNS = 100

    print(f'Замеры сортировки массива случ. вещественных чисел на отрезке '
          f'[0; 50) слиянием ({CNT_RUNS} запусков).')

    results = {}
    for arr_cnt in arr_cnts:
        arr_for_sort = [uniform(0, 50) for _ in range(arr_cnt)]

        print(f'\nМассив {arr_cnt} элементов:')
        print(f'Исходный:',
              *arr_for_sort if arr_cnt < 11 else
              (*arr_for_sort[:5], ' ... ', *arr_for_sort[-5:]))

        sorted_arr = merge_sort(arr_for_sort[:])

        print('Отсорт.: ', *sorted_arr if arr_cnt < 11 else
              (*sorted_arr[:5], ' ... ', *sorted_arr[-5:]))

        results[arr_cnt] = timeit.timeit("merge_sort(arr_for_sort[:])",
                                         globals=globals(), number=CNT_RUNS)

    print(f'\nЗамеры времени времени сортировки:')
    for cnt, time_usage in results.items():
        print(f'{cnt} элементов, время: {time_usage} сек.')
